BASICS


	Java classes:

	package myjavapackage;
	
	class MyClass1
	{
		String a, b, c, d;
	}
	
	class MyClass2 extends MyClass1
	{
		int e;
	}
	
	Inflection views:
	
	// Preamble (package, import) same as Java (as well as syntax for blocks & statements).
	package myinflectpackage;
	
	import myjavapackage.MyClass1;
	import myjavapackage.MyClass2;
	
	taxonomy MyTaxonomy
	{
		default property;
	
		// Annotation of views and fields analogous to Java
		@MyClassAnnotation
		view MyClass1
		{
			@MyAttributeAnnotation( name = "a" )
			a;
			field b;	// overrides "default property"
			c, d;
		}
		
		view MyClass2
		{
			field d;	// overrides "property" modifier in MyClass1
			e;
		}
	}

1. Views are declared within taxonomies by naming the associated class; e.g., the "view MyClass1" declaration
   in MyTaxonomy refers to the myjavapackage.MyClass1 class. There may be zero or one views per class per
   taxonomy.
2. View names are automatically created within the taxonomy namespace based on the viewed Java class; e.g., 
   "view MyClass1" results in a view named myinflectpackage.MyTaxonomy.myjavapackage.MyClass1.
3. Taxonomies and views are stored in individual compilation units that are later loaded and linked analogous
   to Java classes. The rules for compilation unit naming follows the Java conventions of assigning directories
   to package names and using the dollar sign ($) to separate inner classes. Thus, the following compilation
   units would be generated by the example above:
   
	myinflectpackage/MyTaxonomy.view
	myinflectpackage/MyTaxonomy/myjavapackage/MyClass1
	myinflectpackage/MyTaxonomy/myjavapackage/MyClass2
   
ATTRIBUTES
   
1. Views may define attributes that refer to either fields or JavaBean properties of the referenced class; e.g.,
   a refers to the JavaBean property a in the referenced class MyClass1.
2. Attributes may specify a field/property modifier to indicate whether the attribute refers to a field or property
   in the referenced class. The default is property, thus MyClass1.a refers to a property and MyClass1.b to a field.
   The field/property modifier affects how the attribute is accessed when running an inflection algorithm.
4. Taxonomies may override the default modifier by declaring specific defaults; e.g., MyTaxonomy declares the specific
   default property. Default modifiers are inherited by any extending taxonomies.
5. Attributes are automatically typed by views that are derived from the referenced fields/properties; e.g., MyClass1.a
   is automatically assigned the view type java.lang.String (not to be confused with the Java class java.lang.String).
6. Multiple attributes may be listed in one declaration; e.g., c and d in MyClass1 are listed together. In this case,
   any specified modifiers are applied to all listed attributes. As mentioned before, the view types are in any case
   automatically derived.
7. Views and attributes may use Java-style annotations; e.g., MyClass1 and MyClass1.a are annotated with MyClassAnnotation
   and MyAttributeAnnotation respectively.
   
VIEW INHERITANCE
   
1. Views have a notion of inheritance that depends on the inheritance relationships defined in the referenced classes;
   the view MyClass1 is understood to inherit from MyClass2 due to the inheritance relationship defined between the
   referenced classes MyClass1 and MyClass2. Analogous to attributes, inheritance relationships are defined by
   relative views types; e.g., the view MyClass2 is defined as extending myjavapackage.MyClass1 rather than
   myinflectpackage.MyTaxonomy.myjavapackage.MyClass1.
2. If the class referred to by a view extends another class, then the taxonomy must also contain a view of that extended
   class. If no explicit declaration of the extended class exists then an empty view of the extended class will be
   automatically generated at compile time.
3. View inheritance is roughly analogous to Java class inheritance; thus, MyClass2 inherits a, b, c and d from MyClass1.
   As in Java, attributes may be overridden by sub-views; e.g., MyClass2.d overrides MyClass1.d. The effect of
   attribute overriding is that the modifiers and annotations of the overriding attribute are taken instead of those of
   the overridden one; e.g., MyClass2.d specifies the field modifier which overrides the property modifier (implicitly)
   specified by MyClass1.d.

TAXONOMY INHERITANCE


	class MyClass1
	{
		String a, b, c, d;
	}
	
	class MyClass2 extends MyClass1
	{
		int e;
	}
	
	taxonomy MyTaxonomy1
	{
		view MyClass1
		{
			a, b;
		}
	}
	
	taxonomy MyTaxonomy2
	{
		view MyClass1
		{
			c, d;
		}
		
		view MyClass2
		{
			e;
		}
	}
	
	taxonomy MyTaxonomy2 extends MyTaxonomy1, MyTaxonomy2
	{
		view MyClass1
		{
			a, d;
		}
	}

1. Taxonomies may inherit from one or more other taxonomies. If a taxonomy does not specify a particular
   super-taxonomy, then that taxonomy implicitly extends the root taxonomy ch.liquidmind.inflection.
   RootTaxonomy which contains views for basic and common types; e.g., MyTaxonomy1 implicitly extends
   RootTaxonomy.
2. Extending taxonomies inherit all views defined in the extended taxonomies; e.g., MyTaxonomy2 inherits
   MyClass1 and MyClass2 from MyTaxonomy1 and MyTaxonomy2. Conflicts in the super-taxonomy hierarchy are
   resolved by the rule that the first view found in the list of extended taxonomies wins, thus:
   MyTaxonomy1.MyClass1 takes precedence over MyTaxonomy2.MyClass1 since MyTaxonomy2 lists MyTaxonomy1
   first in the extends clause.
3. Just as attributes in sub-views may override attributes inherited from super-views, views in sub-
   taxonomies may override views defined in super-taxonomies. E.g., MyTaxonomy2.MyClass1 overrides
   the MyClass1 that is inherited from MyTaxonomy1.

POLYMORPHIC LINKING

Java classes are loaded and linked by the Java class loader at runtime rather than compile time. This is
known as dynamic linking and it is possible because, according to Java's class loading rules, class
references can always be resolved to exactly one unique class instance. Due to inflection's multiple
taxonomy concept, however, views cannot be simply linked once by the view loader. To understand why,
consider this example:

	class MyClass1
	{}
	
	class MyClass2 extends MyClass1
	{}

	taxonomy MyTaxonomy1
	{
		view MyClass1
		{}
		
		view MyClass2
		{}
	}

	taxonomy MyTaxonomy2
	{
		view MyClass1
		{}
	}

In MyTaxonomy1, MyClass2 (implicitly) defines an inheritance relationship to MyClass1. However, depending on
whether we are operating with MyTaxonomy1 or MyTaxonomy2, the MyClass1 in question might be either 
MyTaxonomy1.MyClass1 or MyTaxonomy2.MyClass1. Therefore, MyClass2 cannot be linked to either of the MyClass1
views until the taxonomic context is known. This is analogous to dynamic invocation in Java where the invoker
doesn't know the location of the actual method to invoke until runtime (when the object type is known).

EXAMPLE

	taxonomy BaseTaxonomy
	{
		view Person
		{
			firstName, lastName;
		}
	
		view Address
		{
			street, zip, city, country;
		}
	
		view Employer
		{
			jobProfile;
		}
	
		view JobProfile
		{
			passionSkills;
		}
	
		view PassionSkills
		{}
	}
	
	taxonomy ConcatPersonTaxonomy extends BaseTaxonomy
	{
		view Person
		{
			fullName;
		}
	}
	
	taxonomy ConcatAddressTaxonomy extends BaseTaxonomy
	{
		view Address
		{
			fullAddress;
		}
	}
	
	taxonomy ConcatAllTaxonomy extends ConcatPersonTaxonomy, ConcatAddressTaxonomy
	{}
	
	taxonomy MatchingTaxonomy extends BaseTaxonomy
	{
		view Employer
		{}
	
		view JobProfile
		{
			employer, passionSkills;
		}
	}

ALIASES

	view Customer as Client
	{
		firstName as givenName;
		lastName as surname;
	}
	
NON-COMPOSITE RELATIONSHIPS
	
	class Customer
	{
		String firstName, lastName;
		List< Address > addresses;
		...
	}
	
	class Address
	{
		String street, city, zip, country;
	}
	
	taxonomy DiscreteTaxonomy
	{
		view Customer
		{
			firstName, lastName, addresses;
		}
		
		view Address
		{}
	}

	The relationship represented by addresses is part of the Customer view, whereas no attributes of Address are included.

TAXONOMY VERSUS VIEW INHERITENCE, DEF/UNDEF

	class MyClass1
	{
		String a, b, c, d;
	}
	
	taxonomy MyTaxonomy1
	{
		view MyClass1
		{
			def a, b, c, d;
		}
	}
	
	taxonomy MyTaxonomy2
	{
		view MyClass1
		{
			def a, b;
			undef c;
		}
	}
	
In this version of taxonomy inheritence, views make the following distinctions:

	Declared Attibutes   Attributes declared directly in the view rather than inherited from
	   the taxonomy or view hierarchy.
	Taxonomy Inheritence   Attributes may be inherited from views referring to the same class
	   in an extended taxonomy.
	View Inheritence   Attributes may be inherited from other views according to the inheritence
	   hierarchy of the referenced classes.
	 
It is possible to specify whether an attribute should be included (def) in or excluded (undef)
from the view. If no modifier is specified then the default is def. Technically, even undef
declarations define attributes in a view---analogous to the getDeclaredFields() and getFields()
methods in java.lang.Class, views distingish between methods for fetching only attributes
with the def modifier or all attributes.

To better understand the motivation behind hiding attributes with undef, consider the following:

	// Classes define bi-directional relationship between each other.
	class MyClass1
	{
		String a, b, c, d, e, f;
		MyClass2 myClass2;
	}
	
	class MyClass2
	{
		String g, h, i, j, k, l;
		MyClass1 myClass1;
	}

	// MyTaxonomy1 views the bi-directional relationship as uni-directional 
	// by omitting MyClass2.myClass1.
	taxonomy MyTaxonomy1
	{
		view MyClass1
		{
			a, b, c, d, e, f, myClass2;
		}
		
		view MyClass2
		{
			g, h, i, j, k, l;
		}
	}
	
	// MyTaxonomy2 reverses the directionality by removing MyClass1.myClass2
	// and adding MyClass2.myClass1.
	taxonomy MyTaxonomy2 extends MyTaxonomy1
	{
		view MyClass1
		{
			undef myClass2;
		}
		
		view MyClass2
		{
			myClass1;
		}
	}
	
Note that MyTaxonomy2 only needs to define the *difference* to MyTaxonomy1; it does not need to
reiterate the inclusion of the fields a to l. Thus, without attribute based taxonomy inheritance,
MyTaxonomy2 would need to be specified as:

	taxonomy MyTaxonomy2 extends MyTaxonomy1
	{
		view MyClass1
		{
			a, b, c, d, e, f;
		}
		
		view MyClass2
		{
			g, h, i, j, k, l, myClass1;
		}
	}


CALCULATED FIELDS

	class Customer
	{
		String firstName, lastName;
		...
	}
	
	class CustomerCalcFields
	{
		static String getFullName( Customer customer )
		{
			return customer.getFirstName() + " " + customer.getLastName();
		}
		
		static void setFullName( Customer customer, String fullName )
		{
			String[] fullNameSplit = fullName.split( " " );
			customer.setFirstName( fullNameSplit[ 0 ] );
			customer.setLastName( fullNameSplit[ 1 ] );
		}
	}
	
	taxonomy CalculatedTaxonomy
	{
		view Customer use CustomerCalcFields
		{
			fullName;
		}
	}

WILDCARDS

	taxonomy MyTaxonomy
	{
		view ch.liquidmind.test.* 
		{
			field *;
		}
	}


RELATED WORK

Database views (do a comparison between these two).











